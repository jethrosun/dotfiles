" .vimrc of Bart Trojanowski
"
" You can get a more upto date version from
"   http://www.jukie.net/~bart/conf/vimrc
"
" Most files sourced by this vimrc are located here:
"   http://www.jukie.net/~bart/conf/vim/
"

" ---------------------------------------------------------------------------
" first the disabled features due to security concerns
set modelines=0         " no modelines [http://www.guninski.com/vim1.html]
"let g:secure_modelines_verbose=1 " securemodelines vimscript

" ---------------------------------------------------------------------------
" configure other scripts

let c_no_curly_error = 1

" ---------------------------------------------------------------------------
" operational settings
set nocompatible                " vim defaults, not vi!
syntax on                       " syntax on
set hidden                      " allow editing multiple unsaved buffers
set more                        " the 'more' prompt
filetype on                     " automatic file type detection
set autoread                    " watch for file changes by other programs
set visualbell                  " visual beep
set backup                      " produce *~ backup files
set backupext=~                 " add ~ to the end of backup files
":set patchmode=~                " only produce *~ if not there
set noautowrite                 " don't automatically write on :next, etc
let maplocalleader=','          " all my macros start with ,
set wildmenu                    " : menu has tab completion, etc
set wildmode=longest,list:longest,list:full
set scrolloff=5                 " keep at least 5 lines above/below cursor
set sidescrolloff=5             " keep at least 5 columns left/right of cursor
set history=200                 " remember the last 200 commands

set cc=80
hi ColorColumn ctermbg=lightred guibg=lightred

" ---------------------------------------------------------------------------
" meta
map <LocalLeader>ce :edit ~/.vimrc<cr>          " quickly edit this file
map <LocalLeader>cs :source ~/.vimrc<cr>        " quickly source this file

" ---------------------------------------------------------------------------
" window spacing
set cmdheight=2                 " make command line two lines high
set ruler                       " show the line number on bar
set lazyredraw                  " don't redraw when running macros
"set number                      " show line number on each line
"set winheight=999               " maximize split windows
"set winminheight=0              " completely hide other windws

map <LocalLeader>w+ 100<C-w>+  " grow by 100
map <LocalLeader>w- 100<C-w>-  " shrink by 100

" ---------------------------------------------------------------------------
" mouse settings
set mouse=                      " disable mouse support in all modes
set mousehide                   " hide the mouse when typing text

" ,p and shift-insert will paste the X buffer, even on the command line
nmap <LocalLeader>p i<S-MiddleMouse><ESC>
imap <S-Insert> <S-MiddleMouse>
cmap <S-Insert> <S-MiddleMouse>

" this makes the mouse paste a block of text without formatting it 
" (good for code)
map <MouseMiddle> <esc>"*p

" ---------------------------------------------------------------------------
" global editing settings
set autoindent smartindent      " turn on auto/smart indenting
set expandtab                   " use spaces, not tabs
set smarttab                    " make <tab> and <backspace> smarter
set tabstop=8                   " tabstops of 8
set shiftwidth=8                " indents of 8
set backspace=eol,start,indent  " allow backspacing over indent, eol, & start
set undolevels=1000             " number of forgivable mistakes
set updatecount=100             " write swap file to disk every 100 chars
set complete=.,w,b,u,U,t,i,d    " do lots of scanning on tab completion
set viminfo=%100,'100,/100,h,\"500,:100,n~/.viminfo

" ---------------------------------------------------------------------------
" searching...
set hlsearch                   " enable search highlight globally
set incsearch                  " show matches as soon as possible
set showmatch                  " show matching brackets when typing
" disable last one highlight
nmap <LocalLeader>nh :nohlsearch<cr>

set diffopt=filler,iwhite       " ignore all whitespace and sync

" ---------------------------------------------------------------------------
" spelling...
if v:version >= 700
  let b:lastspelllang='en'
  function! ToggleSpell()
    if &spell == 1
      let b:lastspelllang=&spelllang
      setlocal spell!
    elseif b:lastspelllang
      setlocal spell spelllang=b:lastspelllang
    else
      setlocal spell spelllang=en
    endif
  endfunction

  nmap <LocalLeader>ss :call ToggleSpell()<CR>

  setlocal spell spelllang=en
  setlocal nospell
endif

" ---------------------------------------------------------------------------
" some useful mappings

" disable search complete
let loaded_search_complete = 1

" Y yanks from cursor to $
map Y y$
" toggle list mode
nmap <LocalLeader>tl :set list!<cr>
" toggle paste mode
nmap <LocalLeader>pp :set paste!<cr>
" change directory to that of current file
nmap <LocalLeader>cd :cd%:p:h<cr>
" change local directory to that of current file
nmap <LocalLeader>lcd :lcd%:p:h<cr>

" word swapping
nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>
" char swapping
nmap <silent> gc xph

" save and build
nmap <LocalLeader>wm  :w<cr>:make<cr>

" this is for the find function plugin
nmap <LocalLeader>ff :let name = FunctionName()<CR> :echo name<CR> 

" http://www.vim.org/tips/tip.php?tip_id=1022
"set foldmethod=expr 
"set foldexpr=getline(v:lnum)!~\"regex\" 

" ---------------------------------------------------------------------------
"  buffer management, note 'set hidden' above

" Move to next buffer
map <LocalLeader>bn :bn<cr>
" Move to previous buffer
map <LocalLeader>bp :bp<cr>
" List open buffers
map <LocalLeader>bb :ls<cr>

" ---------------------------------------------------------------------------
" when switching buffers, preserve window view

" function! MyWinSaveView()
"         if &diff 
"                 let b:winview = winsaveview()
"         endif
" endf
" function! MyWinRestoreView()
"         if &diff 
"                 if(exists('b:winview'))
"                         call winrestview(b:winview)
"                 endif
"         endif
" endf
"
" if v:version >= 700
"         au BufLeave * :call MyWinSaveView()
"         au BufEnter * :call MyWinRestoreView()
" endif 

" ---------------------------------------------------------------------------
" dealing with merge conflicts

" find merge conflict markers
:map <LocalLeader>fc /\v^[<=>]{7}( .*\|$)<CR>


" ---------------------------------------------------------------------------
" parsing issues in quickfix list

" http://stackoverflow.com/questions/6747337/using-vim-make-with-quickfix-ends-up-creating-a-new-file-when-error-is-in-heade
set errorformat^=%-GIn\ file\ included\ %.%# 


" ---------------------------------------------------------------------------

function! OnlineDoc() 
        let s:browser = "firefox"
        let s:wordUnderCursor = expand("<cword>") 

        if &ft == "cpp" || &ft == "c" || &ft == "ruby" || &ft == "php" || &ft == "python" 
                let s:url = "http://www.google.com/codesearch?q=".s:wordUnderCursor."+lang:".&ft
        elseif &ft == "vim"
                let s:url = "http://www.google.com/codesearch?q=".s:wordUnderCursor
        else 
                return 
        endif 

        let s:cmd = "silent !" . s:browser . " " . s:url 
        "echo  s:cmd 
        execute  s:cmd 
        redraw!
endfunction 

" online doc search 
map <LocalLeader>k :call OnlineDoc()<CR>

" ---------------------------------------------------------------------------
" status line 
set laststatus=2
if has('statusline')
        " Status line detail: (from Rafael Garcia-Suarez)
        " %f		file path
        " %y		file type between braces (if defined)
        " %([%R%M]%)	read-only, modified and modifiable flags between braces
        " %{'!'[&ff=='default_file_format']}
        "			shows a '!' if the file format is not the platform
        "			default
        " %{'$'[!&list]}	shows a '*' if in list mode
        " %{'~'[&pm=='']}	shows a '~' if in patchmode
        " (%{synIDattr(synID(line('.'),col('.'),0),'name')})
        "			only for debug : display the current syntax item name
        " %=		right-align following items
        " #%n		buffer number
        " %l/%L,%c%V	line number, total number of lines, and column number
        "function! SetStatusLineStyle()
        "        if &stl == '' || &stl =~ 'synID'
        "                let &stl="%f %y%([%R%M]%)%{'!'[&ff=='".&ff."']}%{'$'[!&list]}" .
        "                                        \"%{'~'[&pm=='']}"                     .
        "                                        \"%=#%n %l/%L,%c%V "                   .
        "                                        \"git:%{call GetGitBranch()}"
        "        else
        "                let &stl="%f %y%([%R%M]%)%{'!'[&ff=='".&ff."']}%{'$'[!&list]}" .
        "                                        \" (%{synIDattr(synID(line('.'),col('.'),0),'name')})" .
        "                                        \"%=#%n %l/%L,%c%V "
        "        endif
        "endfunc
        "call SetStatusLineStyle()

        function! SetStatusLineStyle()
                let &stl="%f %y "                       .
                        \"%([%R%M]%)"                   .
                        \"%#StatusLineNC#%{&ff=='unix'?'':&ff.'\ format'}%*" .
                        \"%{'$'[!&list]}"               .
                        \"%{'~'[&pm=='']}"              .
                        \"%="                           .
                        \"%#StatusLineNC#%{GetGitBranch()}%* " .
                        \"#%n %l/%L,%c%V "              .
                        \""
                 "      \"%#StatusLineNC#%{GetGitBranchInfoString()}%* " .
        endfunc
        call SetStatusLineStyle()

        if has('title')
                set titlestring=%t%(\ [%R%M]%)
        endif

        "highlight StatusLine    ctermfg=White ctermbg=DarkBlue cterm=bold
        "highlight StatusLineNC  ctermfg=White ctermbg=DarkBlue cterm=NONE
endif


" ---------------------------------------------------------------------------
" setup for the visual environment
if has('gui_running')
        set bg=light
        set guioptions-=T
        set guioptions-=m
        set guioptions+=c
        "set guifont=-schumacher-clean-medium-r-normal-*-*-120-*-*-c-*-iso646.1991-irv
        "set guifont=Monospace\ 8,Terminal\ 8,fixed
        set guifont=ProggyCleanTT\ 12
else
        if $TERM =~ '^xterm'
                set t_Co=256 
        elseif $TERM =~ '^screen-bce'
                set t_Co=256            " just guessing
        elseif $TERM =~ '^rxvt'
                set t_Co=88
        elseif $TERM =~ '^linux'
                set t_Co=8
        else
                set t_Co=16
        endif

        "set bg=dark
        set bg=light

        "colorscheme desert              " 16 colour
        "colorscheme ps_color
        "colorscheme desert256           " 256 colour
        "colorscheme gardener            " 256 colour
        "colorscheme inkpot              " 256 colour
        "colorscheme blacklight          " 256 colour

        let g:inkpot_black_background = 1
        colorscheme my_inkpot              " 256 colour

endif


" ---------------------------------------------------------------------------
" Folding for unified diffs 
" http://pastey.net/1483, mgedmin on #vim

function! DiffFoldLevel(lineno) 
        let line = getline(a:lineno) 
        if line =~ '^Index:' 
                return '>1' 
        elseif line =~ '^===' || line =~ '^RCS file: ' || line =~ '^retrieving revision '
                let lvl = foldlevel(a:lineno - 1) 
                return lvl >= 0 ? lvl : '=' 
        elseif line =~ '^diff' 
                return getline(a:lineno - 1) =~ '^retrieving revision ' ? '=' : '>1' 
        elseif line =~ '^--- ' && getline(a:lineno - 1) !~ '^diff\|^===' 
                return '>1' 
        elseif line =~ '^@' 
                return '>2' 
        elseif line =~ '^[- +\\]' 
                let lvl = foldlevel(a:lineno - 1) 
                return lvl >= 0 ? lvl : '=' 
        else 
                return '0' 
        endif 
endf 

function! FT_Diff() 
        if v:version >= 600 
                setlocal foldmethod=expr 
                setlocal foldexpr=DiffFoldLevel(v:lnum) 
        else 
        endif 
endf 
 
" ---------------------------------------------------------------------------
" no folds in vimdiff

function! NoFoldsInDiffMode()
        if &diff 
                :silent! :%foldopen! 
        endif
endf

augroup Diffs 
  autocmd! 
  autocmd BufRead,BufNewFile *.patch :setf diff 
  autocmd BufEnter           *       :call NoFoldsInDiffMode()
  autocmd FileType           diff    :call FT_Diff() 
augroup END

" ---------------------------------------------------------------------------
" force making paths relative to `pwd`
" this is useful if tag files have absolute paths

augroup force-cd-dot
        autocmd!
        autocmd BufEnter * :cd .
augroup END

" ---------------------------------------------------------------------------
" notmuch config

let g:notmuch_debug = 0

" ---------------------------------------------------------------------------
" tabs
map <LocalLeader>tc :tabnew %<cr>    " create a new tab       
map <LocalLeader>td :tabclose<cr>    " close a tab
map <LocalLeader>tn :tabnext<cr>     " next tab
map <LocalLeader>tp :tabprev<cr>     " previous tab
map <LocalLeader>tm :tabmove         " move a tab to a new location

" "dcraven" pasted "TabMessage: Put output of ex commands in a new tab." 
" (10 lines, 287B) at http://sial.org/pbot/20504

"TabMessage: Put output of ex commands in a new tab.
function! TabMessage(cmd)
        redir => message
        silent execute a:cmd
        redir END
        tabnew
        silent put=message
        set nomodified
endfunction
command! -nargs=+ -complete=command TabMessage call TabMessage(<q-args>)

" ---------------------------------------------------------------------------
" auto load extensions for different file types
if has('autocmd')
        filetype plugin indent on
        syntax on

        " jump to last line edited in a given file (based on .viminfo)
        "autocmd BufReadPost *
        "       \ if !&diff && line("'\"") > 0 && line("'\"") <= line("$") |
        "       \       exe "normal g`\"" |
        "       \ endif
        autocmd BufReadPost *
                \ if line("'\"") > 0|
                \       if line("'\"") <= line("$")|
                \               exe("norm '\"")|
                \       else|
                \               exe "norm $"|
                \       endif|
                \ endif

        " improve legibility
        au BufRead quickfix setlocal nobuflisted wrap number

        " configure various extenssions
        let git_diff_spawn_mode=2

        " improved formatting for markdown
        " http://plasticboy.com/markdown-vim-mode/
        autocmd BufRead *.mkd  set ai formatoptions=tcroqn2 comments=n:>
        autocmd BufRead ~/.blog/entries/*  set ai formatoptions=tcroqn2 comments=n:>
endif

" ---------------------------------------------------------------------------
"import other files...
":source ~/.vim/bk.vim      " does anyone actualy use bk anymore?

let $kernel_version=system('uname -r | tr -d "\n"')
set tags=./tags,tags,../tags,../../tags,../../../tags,../../../../tags,/lib/modules/$kernel_version/build/tags,/usr/include/tags

helptags ~/.vim/doc

set dictionary=/usr/share/dict/words            " used with CTRL-X CTRL-K

" ---------------------------------------------------------------------------
"run the import script that looks for localized configuration changes
source ~/.vim/localized_vimrc.vim

source ~/.vim/passwords.vim

" ---------------------------------------------------------------------------
"configure other scripts

" enable autoinstall of scripts w/o markup
" see :h :GLVS
let g:GetLatestVimScripts_allowautoinstall=1

" dynamic-explorer.vim (script 1890)
nmap <silent> <LocalLeader>f :FilesystemExplorer<CR>
nmap <silent> <LocalLeader>b :BufferExplorer<CR>

" ---------------------------------------------------------------------------
" vim-addon-manager
" http://github.com/MarcWeber/vim-addon-manager/blob/master/doc/vim-addon-manager.txt

"set runtimepath+=~/.vim/addons/vim-addon-manager
"let g:vim_script_manager = { }
"let g:vim_script_manager['plugin_root_dir'] = expand('$HOME').'/etc/vim/addons' 
"try
"        "call scriptmanager#Activate([])
"        "call scriptmanager#Activate(['vim-addon-background-cmd'])
"catch /.*/
"        echoe v:exception
"endtry


" ---------------------------------------------------------------------------
"this is for hg menu
if filereadable( "/usr/share/doc/mercurial/examples/hg-menu.vim" )
        let $backup_mapleader=mapleader
        let mapleader = ","
        source /usr/share/doc/mercurial/examples/hg-menu.vim
        let mapleader = $backup_mapleader
endif

" ===========================================================================
" ===========================================================================


" ---------------------------------------------------------------------------
"  configure calendar
let g:calendar_monday = 1



